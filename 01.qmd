---
date: today
date-format: long
title: Computer Simulations
subtitle: Report 1
authors:
- name: Jakub Kaczor
  email: 262257@student.pwr.edu.pl
  affiliations:
  - name: Wrocław University of Science and Technology
    city: Wrocław
- name: Karolina Jonczyk
  affiliations:
  - name: Wrocław University of Science and Technology
    city: Wrocław

callout-appearance: simple
---

# Statistics

In the following work, the authors are going to assess the implemented
methods by various means. Descriptive statistics are one of them. Here,
they present the implementation of each.

```{julia}
using Test
# Used only for testing
import Statistics as Stats
import StatsBase

const TEST_SAMPLE = randn(10^3)

"Compute arithmetic mean over the elements of an array"
function mean(A::AbstractArray)
   sum(A) / length(A)
end

@test mean(TEST_SAMPLE) ≈ Stats.mean(TEST_SAMPLE)

"Compute variance over the elements of an array"
function var(A::AbstractArray, mean=mean(A))
   sum(@. (A - mean)^2) / (length(A) - 1)
end

@test var(TEST_SAMPLE) ≈ Stats.var(TEST_SAMPLE)

"Compute standard deviation over the elements of an array"
function std(A::AbstractArray)
   A |> var |> sqrt
end

@test std(TEST_SAMPLE) ≈ Stats.std(TEST_SAMPLE)

"Compute skewness over the elements of an array"
function skewness(A::AbstractArray, mean=mean(A), var=var(A))
   n = length(A)
   (sum((A .- mean).^3) / n) / var^(3/2)
end

# TODO: Investigate why the difference is so big
@test isapprox(skewness(TEST_SAMPLE), StatsBase.skewness(TEST_SAMPLE), rtol=10e-3)

"Compute kurtosis over the elements of an array"
function kurtosis(A::AbstractArray, mean=mean(A))
   n = length(A)
   (n - 1) * n * (n + 1) / (n - 2) / (n - 3) * sum((A .- mean).^4) /
   sum((A .- mean).^2)^2 - 3(n - 1)^2 / (n - 2) / (n - 3)
end

# TODO: Investigate why the difference is so big
@test isapprox(kurtosis(TEST_SAMPLE), StatsBase.kurtosis(TEST_SAMPLE), rtol=10e-1)
```

# The Ziggurat Method

## Peculiarities

There is some peculiarity with using this method with distributions having
the support being an interval not beginning in $0$. The original algorithm
samples points from the uniform distribution over subintervals of the
support, the subintervals having the left ends equal to $0$, only differing
in right ends, corresponding to strips' right end coordinates. The authors
see two solutions.

One can try to translate the functions defining the distribution, so it is
properly situated. The other comes down to altering the uniform sampling
procedure, so the points are properly sampled from shifted intervals. The
latter comes with the additional cost of addition and subtraction with each
uniform sampling, but the former requires these only in the initial
procedure of identifying the ziggurat's structure and one addition on
returning the final realization. But this also requires one to transform
the PDF and its inverse symbolically beforehand, so the user cannot blindly
pass well-known functions to the general version of the algorithm. But in
the other solution, one would also have to give a specification of uniform
distributions to sample from (the shift parameter), so the authors settled
down on the idea of transforming density, which is equivalent to composing
it with a translation by a constant factor and finding the inverse.

There is also one subtlety with a method showed in the article. During
determination of the strips' coordinates by zeroing the $z$ function, for
example by using bisection method, one has to evaluate it possibly at
negative values, where it can be undefined. It happened in the case of the
Pareto distribution in the following example. One can avoid it evaluating
the $z$ function in the absolute values of points instead. The results may
not be formally correct, but they are good in our example, so the authors
settle on this solution.

## Example (Pareto distribution)

It is easy to determine the area $A_{\text {tail}}$ of the tail, as it is
given by the definition of the Pareto distribution. That is
$$
A_{\text {tail}} = \bar F = \begin {cases}
   {\left(\frac {x_m} \alpha\right)}^\alpha, x_m > x,
   1, x_m \leq x,
\end {cases}
$$
where $x_m$ is a scale parameter and $\alpha$ is a shape parameter.

In this case, the distribution's support is $[x_m, \infty]$. Therefore, in
the beginning, the distribution specific functions are shifted by $x_m$
parameter, as mentioned in @sec:Peculiarities.

### Implementation

```{julia}
import Roots: find_zero

"""
Return a Pareto distribution generator

The returned generator uses the ziggurat method.
"""
function ParetoGenerator(shape, scale)
   n_strips = 256
   # Pareto specific functions
   # Usual Pareto's PDF composed with translation
   pdf(x) = (shape * scale^shape) / (x + scale)^(shape + 1)
   inverted_pdf(y) = (shape * scale^shape / y)^(1/(shape + 1)) - scale
   tail(x) = x >= 0 ? (scale / (x + scale))^shape : 1
   # Used for inverse sampling from the tail
   quantile(x) = scale * (1 - x)^(-1/shape) - scale

   # Determine the ziggurat's structure
   step_points = Array{Float64}(undef, n_strips)
   function to_be_zeroed(rightmost)
      area = rightmost * pdf(rightmost) + tail(rightmost)
      step_points[end] = rightmost
      for i in lastindex(step_points)-1 : -1 : firstindex(step_points)+1
         previous = step_points[i+1]
         # `abs` prevents invalid values in `inverted_pdf`
         height = area / abs(previous) + pdf(previous)
         step_points[i] = inverted_pdf(height)
      end
      first = step_points[begin+1]
      return area - first * (pdf(0) - pdf(first))
   end

   # Initial guess
   somewhere_far = quantile((n_strips-1)/n_strips)
   rightmost = find_zero(to_be_zeroed, somewhere_far)
   area = rightmost * pdf(rightmost) + tail(rightmost)

   for i ∈ lastindex(step_points)-1 : -1 : firstindex(step_points)+1
      prev = step_points[i+1]
      step_points[i] = inverted_pdf(area / prev + pdf(prev))
   end
   # The special value
   step_points[begin] = pdf(rightmost) * rightmost / area
   
   () -> begin
      while true
         # Choose a strip
         i = rand(UInt8) + 1
         x = rand() * step_points[i]
         if i != 1 && x <= step_points[i-1]
            return x + scale
         end
         # Choose from the tail
         if i == 1
            x = rand() * rightmost
            if x <= step_points[end]
               return x + scale
            end
         end
         if rand() * (pdf(step_points[i-1]) - pdf(step_points[i])) < pdf(x) - pdf(step_points[i])
            return x + scale
         end
      end
   end
end
```
```{julia}
using Plots
using Distributions

d = Pareto(1, 1)
gen = ParetoGenerator(1, 1)
smpl = [gen() for _ in 1:10^6]

histogram(smpl, normalize=true)
plot!(0:0.01:5, x -> pdf(d, x))
xlims!(0, 5)
```
