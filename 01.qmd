---
date: today
date-format: long
title: Computer Simulations
subtitle: Report 1
authors:
- name: Karolina Jonczyk
  affiliations:
  - name: Wrocław University of Science and Technology
    city: Wrocław
- name: Jakub Kaczor
  email: 262257@student.pwr.edu.pl
  affiliations:
  - name: Wrocław University of Science and Technology
    city: Wrocław

callout-appearance: simple
---

# Statistics

In the following work, the authors are going to assess the implemented
methods by various means. Descriptive statistics are one of them. Here,
they present the implementation of each.

```{julia}
using Test
# Used only for testing
import Statistics as Stats
import StatsBase

const TEST_SAMPLE = randn(10^3)

"Compute arithmetic mean over the elements of an array"
function mean(A::AbstractArray)
   sum(A) / length(A)
end

@test mean(TEST_SAMPLE) ≈ Stats.mean(TEST_SAMPLE)

"Compute variance over the elements of an array"
function var(A::AbstractArray, mean=mean(A))
   sum(@. (A - mean)^2) / (length(A) - 1)
end

@test var(TEST_SAMPLE) ≈ Stats.var(TEST_SAMPLE)

"Compute standard deviation over the elements of an array"
function std(A::AbstractArray)
   A |> var |> sqrt
end

@test std(TEST_SAMPLE) ≈ Stats.std(TEST_SAMPLE)

"Compute skewness over the elements of an array"
function skewness(A::AbstractArray, mean=mean(A), var=var(A))
   n = length(A)
   (sum((A .- mean).^3) / n) / var^(3/2)
end

# TODO: Investigate why the difference is so big
@test isapprox(skewness(TEST_SAMPLE), StatsBase.skewness(TEST_SAMPLE), rtol=10e-3)

"Compute kurtosis over the elements of an array"
function kurtosis(A::AbstractArray, mean=mean(A))
   n = length(A)
   (n - 1) * n * (n + 1) / (n - 2) / (n - 3) * sum((A .- mean).^4) /
   sum((A .- mean).^2)^2 - 3(n - 1)^2 / (n - 2) / (n - 3)
end

# TODO: Investigate why the difference is so big
@test isapprox(kurtosis(TEST_SAMPLE), StatsBase.kurtosis(TEST_SAMPLE), rtol=10e-1)
```

```{julia}
import Markdown
import Plots
import StatsPlots
import Distributions as Dists

struct GeneratorTestStatisticsError
   distribution
   mean
   var
   skewness
   kurtosis
end

function GeneratorTestStatisticsError(distribution, sample)
   GeneratorTestStatisticsError(
      distribution,
      mean(sample),
      var(sample),
      skewness(sample),
      kurtosis(sample),
   )
end

function Base.show(
   io::IO,
   mime::MIME"text/markdown",
   generator_test_statistics::GeneratorTestStatisticsError
)
   distribution = generator_test_statistics.distribution
   names = ["Statistic", "mean", "variance", "skewness", "kurtosis"]
   absolute_errors = [
      "Absolute error",
      generator_test_statistics.mean - Dists.mean(distribution),
      generator_test_statistics.var - Dists.var(distribution),
      generator_test_statistics.skewness - Dists.skewness(distribution),
      generator_test_statistics.kurtosis - Dists.kurtosis(distribution),
   ]
   theoretic_values = [
      "Theoretic value",
      Dists.mean(distribution),
      Dists.var(distribution),
      Dists.skewness(distribution),
      Dists.kurtosis(distribution),
   ]
   rows = map(zip(names, absolute_errors, theoretic_values)) do (name, error, value)
      [name, error, value]
   end
   md = Markdown.MD(Markdown.Table(rows, [:l, :l, :l]))
   Base.show(io, mime, md)
end

struct GeneratorTestPlots
   cdf
   pdf
   qq
end

function Base.show(io::IO, test_plots::GeneratorTestPlots)
   p = Plots.plot(test_plots.cdf, test_plots.pdf, test_plots.qq)
   Base.display(p)
end

struct GeneratorTest
   statistics::GeneratorTestStatisticsError
   plots::GeneratorTestPlots
end

function test_generator(distribution, generator, sample_size=10^3)
   sample = [generator() for _ in 1:sample_size]
   test_statistics = GeneratorTestStatisticsError(distribution, sample)
   sample_ecdf = StatsBase.ecdf(sample)
   cdf_plot = StatsPlots.plot(sample_ecdf, label="Empirical CDF")
   Plots.plot!(cdf_plot, x -> Dists.cdf(distribution, x), label="Theoretic CDF")
   Plots.title!(cdf_plot, "Cumulative distribution function")
   Plots.xlabel!(cdf_plot, "Argument")
   Plots.ylabel!(cdf_plot, "Value")

   if distribution isa Dists.DiscreteDistribution
      proportion_map = StatsBase.proportionmap(sample)
      plot_points = unique(sample)
      epmf(x) = proportion_map[x]
      pdf_plot = StatsPlots.groupedbar(
         plot_points,
         [epmf.(plot_points) (x -> Dists.pdf(distribution, x)).(plot_points)],
         labels=["Empirical PMF" "Theoretic PMF"]
      )
      Plots.title!(pdf_plot, "Probability Mass Function")
      Plots.xlabel!(pdf_plot, "Argument")
      Plots.xticks!(plot_points)
      Plots.ylabel!(pdf_plot, "Probability")
   elseif distribution isa Dists.ContinuousDistribution
      pdf_plot = Plots.histogram(sample, normalize=true, label="Histogram")
      StatsPlots.plot!(
         x -> Dists.pdf(distribution, x), label="Theoretic density"
      )
      Plots.title!(pdf_plot, "Probability density function")
      Plots.xlabel!(pdf_plot, "Argument")
      Plots.ylabel!(pdf_plot, "Probability density")
   else
      error("distribution of a mixed type is not allowed")
   end

   qq_plot = StatsPlots.qqplot(distribution, sample)
   Plots.title!(qq_plot, "Quantile-Quantile")
   Plots.xlabel!(qq_plot, "Theoretic quantile")
   Plots.ylabel!(qq_plot, "Empirical quantile")

   test_plots = GeneratorTestPlots(cdf_plot, pdf_plot, qq_plot)
   GeneratorTest(test_statistics, test_plots)
end
```

# Inverse Transform Sampling

```{julia}
function InverseTransformSamplingGenerator(quantile)
   () -> begin
      u = rand()
      quantile(u)
   end
end
```

## Continuous Example (Weibull(2, 1))
```{julia}
distribution = Dists.Weibull(2)
generator = InverseTransformSamplingGenerator(x -> (-log(1 - x))^(1/2))
test = test_generator(distribution, generator)
display(test.plots); display(test.statistics)
```

## Discrete Example (Bernoulli(1/2))
```{julia}
distribution = Dists.Bernoulli(1/2)
bernoulli_quantile(x) = x <= 1/2 ? 0 : 1
generator = InverseTransformSamplingGenerator(bernoulli_quantile)
test = test_generator(distribution, generator)
display(test.plots); display(test.statistics)
```

# Rejection sampling

```{julia}
function RejectionSamplingGenerator(pdf, aux_pdf, aux_gen, multiplier)
   () -> begin
      while true
         x = aux_gen()
         if (u = rand()) <= pdf(x) / (multiplier * aux_pdf(x))
            return x
         end
      end
   end
end
```

## Continuous Example (Semicircle(1) with Uniform(-1, 1))

```{julia}
distribution = Dists.Semicircle(1)
semicircle_pdf(x) = -1 <= x <= 1 ? 2/π * sqrt(1 - x^2) : 0
uniform_pdf(x) = -1 <= x <= 1 ? 1 : 0
generator = RejectionSamplingGenerator(
   semicircle_pdf, uniform_pdf, () -> 2 * rand() - 1, 1
)
test = test_generator(distribution, generator)
display(test.plots); display(test.statistics)
```

## Discrete Example (Bernoulli(1/4) with Uniform(0..1))

```{julia}
distribution = Dists.Bernoulli(1/4)

bernoulli_pmf(x) = begin
   if x == 0
      3/4
   elseif x == 1
      1/4
   else
      0
   end
end

uniform_pmf(x) = begin
   if x == 0
      1/2
   elseif x == 1
      1/2
   else
      0
   end
end

generator = RejectionSamplingGenerator(
   bernoulli_pmf, uniform_pmf, () -> rand([0, 1]), 3/2
)
test = test_generator(distribution, generator)
display(test.plots); display(test.statistics)
```

# Normal distribution generation methods

## Box-Muller transform

```{julia}
function BoxMullerGenerator(μ=0, σ²=1)
   σ = sqrt(σ²)
   () -> begin
      u₁, u₂ = rand(2)
      z₁, z₂ = sqrt(-2 * log(u₁)) * cos(2π * u₂), sqrt(-2 * log(u₁)) *
         sin(2π * u₂)
      [σ * z₁ + μ, σ * z₂ + μ]
   end
end
```

## Polar method

```{julia}
function PolarMethod(μ=0, σ²=1)
   σ = sqrt(σ²)
   () -> begin
      while true
         u₁, u₂ = 2 .* rand(2) .- 1
         R² = u₁^2 + u₂^2
         if R² <= 1
            z₁, z₂ = sqrt(-2 * log(R²) / R²) * u₁, sqrt(-2 * log(R²) / R²) * u₂
            return [σ * z₁ + μ, σ * z₂ + μ]
         end
      end
   end
end
```

## Rejection sampling

```{julia}
normal_pdf(x) = 1/2π * exp(-x^2/2)
laplace_pdf(x) = 1/2 * exp(-abs(x))
exponential_quantile(x) = -log(1 - x)
laplace_generator = ComposedFunction(
   x -> x * rand([-1, 1]),
   InverseTransformSamplingGenerator(exponential_quantile),
)
normal_rejection_sampling_generator = RejectionSamplingGenerator(
   normal_pdf,
   laplace_pdf,
   laplace_generator,
   20
)
```

## Benchmarks

```{julia}
import BenchmarkTools as BT
import DataFrames as DF
using LaTeXStrings

exponents = 1:4
sample_sizes = [10^i for i in exponents]
generators = [
   BoxMullerGenerator(), PolarMethod(), normal_rejection_sampling_generator
]
results = Array{Any}(undef, (length(generators), length(sample_sizes)))

results = map(Base.Iterators.product(exponents, 1:3)) do (i, j)
   result = BT.@benchmark [$generators[$j]() for _ in 1:$sample_sizes[$i]]
   result.times
end

median_results = map(Stats.median, results)

the_plots = map(exponents) do exponent
   p = StatsPlots.groupedbar(
      median_results[exponent, :],
      group=["Box-Muller", "Polar", "Rejection"],
      legend=:none,
   )
   Plots.title!(p, L"Sample size $10^%$exponent$")
   Plots.ylabel!(p, "Time")
   Plots.xticks!(p, [0])
end
legend = Plots.plot(
   [0 0 0],
   showaxis = false,
   grid = false,
   label=["Box-Muller" "Polar" "Rejection"]
)
p = Plots.plot(
      the_plots...,
      legend,
      legend_title="Median",
      layout=Plots.@layout [Plots.grid(2, 2) l{0.2w}]
   )
```

# The Ziggurat Method

## Peculiarities

There is some peculiarity with using this method with distributions having
the support being an interval not beginning in $0$. The original algorithm
samples points from the uniform distribution over subintervals of the
support, the subintervals having the left ends equal to $0$, only differing
in right ends, corresponding to strips' right end coordinates. The authors
see two solutions.

One can try to translate the functions defining the distribution, so it is
properly situated. The other comes down to altering the uniform sampling
procedure, so the points are properly sampled from shifted intervals. The
latter comes with the additional cost of addition and subtraction with each
uniform sampling, but the former requires these only in the initial
procedure of identifying the ziggurat's structure and one addition on
returning the final realization. But this also requires one to transform
the PDF and its inverse symbolically beforehand, so the user cannot blindly
pass well-known functions to the general version of the algorithm. But in
the other solution, one would also have to give a specification of uniform
distributions to sample from (the shift parameter), so the authors settled
down on the idea of transforming density, which is equivalent to composing
it with a translation by a constant factor and finding the inverse.

There is also one subtlety with a method showed in the article. During
determination of the strips' coordinates by zeroing the $z$ function, for
example by using bisection method, one has to evaluate it possibly at
negative values, where it can be undefined. It happened in the case of the
Pareto distribution in the following example. One can avoid it evaluating
the $z$ function in the absolute values of points instead. The results may
not be formally correct, but they are good in our example, so the authors
settle on this solution.

## Example (Pareto distribution)

It is easy to determine the area $A_{\text {tail}}$ of the tail, as it is
given by the definition of the Pareto distribution. That is
$$
A_{\text {tail}} = \bar F = \begin {cases}
   {\left(\frac {x_m} \alpha\right)}^\alpha, x_m > x,
   1, x_m \leq x,
\end {cases}
$$
where $x_m$ is a scale parameter and $\alpha$ is a shape parameter.

In this case, the distribution's support is $[x_m, \infty]$. Therefore, in
the beginning, the distribution specific functions are shifted by $x_m$
parameter, as mentioned in @sec:Peculiarities.

### Implementation

```{julia}
import Roots: find_zero

"""
Return a Pareto distribution generator

The returned generator uses the ziggurat method.
"""
function ParetoGenerator(shape, scale)
   n_strips = 256
   # Pareto specific functions
   # Usual Pareto's PDF composed with translation
   pdf(x) = (shape * scale^shape) / (x + scale)^(shape + 1)
   inverted_pdf(y) = (shape * scale^shape / y)^(1/(shape + 1)) - scale
   tail(x) = x >= 0 ? (scale / (x + scale))^shape : 1
   # Used for inverse sampling from the tail
   quantile(x) = scale * (1 - x)^(-1/shape) - scale

   # Determine the ziggurat's structure
   step_points = Array{Float64}(undef, n_strips)
   function to_be_zeroed(rightmost)
      area = rightmost * pdf(rightmost) + tail(rightmost)
      step_points[end] = rightmost
      for i in lastindex(step_points)-1 : -1 : firstindex(step_points)+1
         previous = step_points[i+1]
         # `abs` prevents invalid values in `inverted_pdf`
         height = area / abs(previous) + pdf(previous)
         step_points[i] = inverted_pdf(height)
      end
      first = step_points[begin+1]
      return area - first * (pdf(0) - pdf(first))
   end

   # Initial guess
   somewhere_far = quantile((n_strips-1)/n_strips)
   rightmost = find_zero(to_be_zeroed, somewhere_far)
   area = rightmost * pdf(rightmost) + tail(rightmost)

   for i ∈ lastindex(step_points)-1 : -1 : firstindex(step_points)+1
      prev = step_points[i+1]
      step_points[i] = inverted_pdf(area / prev + pdf(prev))
   end
   # The special value
   step_points[begin] = pdf(rightmost) * rightmost / area
   
   () -> begin
      while true
         # Choose a strip
         i = rand(UInt8) + 1
         x = rand() * step_points[i]
         if i != 1 && x <= step_points[i-1]
            return x + scale
         end
         # Choose from the tail
         if i == 1
            x = rand() * rightmost
            if x <= step_points[end]
               return x + scale
            end
         end
         if rand() * (pdf(step_points[i-1]) - pdf(step_points[i])) < pdf(x) - pdf(step_points[i])
            return x + scale
         end
      end
   end
end
```
```{julia}
distribution = Dists.Pareto(5, 1)
generator = ParetoGenerator(5, 1)
test = test_generator(distribution, generator)

# Make plots more readable, correcting for Pareto's infinite tail
Plots.xlims!(test.plots.cdf, 0.9, 2.5)
Plots.xlims!(test.plots.pdf, 0.9, 2.5)
Plots.xlims!(test.plots.qq, 0.9, 2.5)
Plots.ylims!(test.plots.qq, 0.9, 2.5)

display(test.plots); display(test.statistics)
```
